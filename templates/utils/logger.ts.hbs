/**
* Logger utility for {{projectName}}
* Generated by swagger-to-nextjs
*
* This is a simple console-based logger.
* You can replace this with your preferred logging library:
* - winston: https://github.com/winstonjs/winston
* - pino: https://github.com/pinojs/pino
* - bunyan: https://github.com/trentm/node-bunyan
*/

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogEntry {
timestamp: string;
level: LogLevel;
message: string;
data?: any[];
}

class Logger {
private isDevelopment = process.env.NODE_ENV === 'development';
private isTest = process.env.NODE_ENV === 'test';
private logLevel: LogLevel = this.isDevelopment ? 'debug' : 'info';

/**
* Set the minimum log level
*/
setLogLevel(level: LogLevel) {
this.logLevel = level;
}

/**
* Check if a log level should be output
*/
private shouldLog(level: LogLevel): boolean {
const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
const currentLevelIndex = levels.indexOf(this.logLevel);
const messageLevelIndex = levels.indexOf(level);
return messageLevelIndex >= currentLevelIndex;
}

/**
* Format log entry for output
*/
private formatLogEntry(entry: LogEntry): string {
const prefix = `[${entry.timestamp}] [${entry.level.toUpperCase()}]`;
return prefix;
}

/**
* Core logging method
*/
private log(level: LogLevel, message: string, ...args: any[]) {
if (!this.shouldLog(level)) {
return;
}

const entry: LogEntry = {
timestamp: new Date().toISOString(),
level,
message,
data: args.length > 0 ? args : undefined,
};

const prefix = this.formatLogEntry(entry);

// In test environment, store logs instead of console output
if (this.isTest) {
// You can implement test log storage here
return;
}

switch (level) {
case 'debug':
console.debug(prefix, message, ...args);
break;
case 'info':
console.info(prefix, message, ...args);
break;
case 'warn':
console.warn(prefix, message, ...args);
break;
case 'error':
console.error(prefix, message, ...args);
break;
}
}

/**
* Debug level logging
*/
debug(message: string, ...args: any[]) {
this.log('debug', message, ...args);
}

/**
* Info level logging
*/
info(message: string, ...args: any[]) {
this.log('info', message, ...args);
}

/**
* Warning level logging
*/
warn(message: string, ...args: any[]) {
this.log('warn', message, ...args);
}

/**
* Error level logging with special error handling
*/
error(message: string, error?: Error | any, ...args: any[]) {
if (error instanceof Error) {
this.log('error', message, {
name: error.name,
message: error.message,
stack: error.stack,
...args,
});
} else {
this.log('error', message, error, ...args);
}
}

/**
* Create a child logger with context
*/
child(context: Record<string, any>): ContextLogger {
return new ContextLogger(this, context);
}
}

/**
* Context logger that includes additional context in all logs
*/
class ContextLogger {
constructor(
private parent: Logger,
private context: Record<string, any>
) {}

debug(message: string, ...args: any[]) {
this.parent.debug(message, this.context, ...args);
}

info(message: string, ...args: any[]) {
this.parent.info(message, this.context, ...args);
}

warn(message: string, ...args: any[]) {
this.parent.warn(message, this.context, ...args);
}

error(message: string, error?: Error | any, ...args: any[]) {
this.parent.error(message, error, this.context, ...args);
}
}

// Export singleton instance
export const logger = new Logger();

// Export types for extending
export type { Logger, ContextLogger, LogLevel, LogEntry };