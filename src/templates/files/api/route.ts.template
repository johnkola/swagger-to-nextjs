# ===AI PROMPT ==============================================================
# FILE: src/templates/files/api/route.ts.template
# VERSION: 2025-05-25 13:22:11
# ============================================================================
#
# AI GENERATION PROMPT:
# Create a TypeScript template for NextJS App Router API route handlers.
# Include parameter validation, request/response typing, error handling, and
# OpenAPI operation mapping.
#
# ---
#
# ===PROMPT END ==============================================================
/**
 * AI PROMPT FOR CODE GENERATION:
 * ================================
 *
 * You are a Next.js API developer. Generate a complete implementation for this API route.
 *
 * ROUTE INFORMATION:
 * - Path: {{routePath}}
 * - Methods: {{methods.join(', ')}}
 * - Framework: Next.js 13+ App Router
 * - TypeScript: Yes
 *
{{#each aiPromptData.methodRequirements}}
{{this.method}} METHOD REQUIREMENTS:
- Summary: {{this.summary}}
- Description: {{this.description}}
{{#if this.parameters}}
- Parameters:
{{#each this.parameters}}
  * {{this.name}} ({{this.location}}): {{this.type}} - {{this.description}}
  {{#if this.required}}Required: Yes{{/if}}
  {{#if this.allowedValues}}Allowed values: {{this.allowedValues.join(', ')}}{{/if}}
{{/each}}
{{/if}}
{{#if this.requestBody}}
- Request Body:
  * Description: {{this.requestBody.description}}
  * Content Types: {{this.requestBody.contentTypes.join(', ')}}
{{/if}}
- Expected Responses:
{{#each this.responses}}
  * {{this.code}}: {{this.description}}
  {{#if this.contentTypes}}Content Types: {{this.contentTypes.join(', ')}}{{/if}}
{{/each}}

{{/each}}
 * IMPLEMENTATION REQUIREMENTS:
 * 1. Use Next.js 13+ App Router API route format
 * 2. Implement proper TypeScript types
 * 3. Add comprehensive error handling
 * 4. Validate request parameters and body
 * 5. Return appropriate HTTP status codes
 * 6. Follow RESTful conventions
 * 7. Add proper CORS headers if needed
 * 8. Implement authentication/authorization if required
 * 9. Add request logging for debugging
 * 10. Use environment variables for configuration
 *
 * EXAMPLE PATTERNS TO FOLLOW:
 * - Use try-catch blocks for error handling
 * - Validate input using Zod or similar
 * - Return NextResponse.json() for all responses
 * - Extract path/query parameters properly
 * - Handle different content types appropriately
 *
{{#if swaggerDoc.components.schemas}}
 * AVAILABLE SCHEMAS:
{{#each aiPromptData.availableSchemas}}
 * - {{this.name}}: {{this.schema}}
{{/each}}
{{/if}}
 *
 * DATABASE/EXTERNAL SERVICES:
 * - Assume you have access to a database connection
 * - Use async/await for database operations
 * - Implement proper connection pooling
 * - Handle database errors gracefully
 *
 * GENERATE: Complete, production-ready code with all necessary imports, types, and logic.
 */

// API Route: {{routePath}}
// Generated from Swagger/OpenAPI specification
// Methods: {{methods.join(', ')}}
// TODO: Remove this comment block after AI implementation

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

{{#if relevantSchemas}}
import { {{relevantSchemas.join(', ')}} } from '@/lib/api-client/model';
{{/if}}
import { {{apiClassName}}, Configuration } from '@/lib/api-client/api';

// TypeScript interfaces from OpenAPI generated models
{{#if relevantSchemas}}
{{#each relevantSchemas}}
// {{this}} - imported from generated API client
{{/each}}
{{else}}
// No specific models found - using generic types
{{/if}}

// Request validation schemas
{{#each validationSchemas}}
const {{this.name}} = z.object({
{{#each this.fields}}
  {{this.name}}: {{this.zodType}}{{#unless this.optional}}.optional(){{/unless}}, // {{this.description}}
{{/each}}
});

{{/each}}

{{#each methods}}
/**
 * {{this}} {{../routePath}}
{{#if operations.[this].summary}} * Summary: {{operations.[this].summary}}{{/if}}
{{#if operations.[this].description}} * Description: {{operations.[this].description}}{{/if}}
{{#if operations.[this].parameters}}
 * Parameters:
{{#each operations.[this].parameters}}
 *   - {{this.name}} ({{this.in}}): {{this.description}}
{{/each}}
{{/if}}
{{#if operations.[this].requestBody}}
 * Request Body: {{operations.[this].requestBody.description}}
{{/if}}
{{#if operations.[this].responses}}
 * Responses:
{{#each operations.[this].responses}}
 *   - {{@key}}: {{this.description}}
{{/each}}
{{/if}}
 */
export async function {{this}}(request: NextRequest) {
  try {
    console.log(`${new Date().toISOString()} - {{this}} {{../routePath}} - Request received`);

{{#if ../hasQueryParams}}
    // Extract and validate query parameters
    const url = new URL(request.url);
    const queryParams = {
      // TODO: Extract specific query parameters based on OpenAPI spec
    };

    // Validate query parameters
    // const validatedQuery = {{this.toLowerCase}}QuerySchema.parse(queryParams);
{{/if}}

{{#if ../hasPathParams}}
    // Extract path parameters
{{#each ../pathParams}}
    // Path parameter: {{this}} - extract from URL
{{/each}}
{{/if}}

{{#if ../hasRequestBody}}
    // Parse and validate request body
    const body = await request.json();

    // Type assertion based on OpenAPI schema
    const typedBody = body as any; // TODO: Use specific type from OpenAPI
{{/if}}

    // Business logic implementation using OpenAPI generated client
    // 1. Authentication/Authorization check
    // const authToken = request.headers.get('authorization');
    // if (!authToken) throw new Error('Unauthorized');

    // 2. Initialize API client with configuration
    const config = new Configuration({
      basePath: process.env.API_BASE_URL || 'http://localhost:8090',
      // accessToken: authToken?.replace('Bearer ', ''),
    });
    const apiClient = new {{../apiClassName}}(config);

    // 3. Call the appropriate API method
    // Example: const result = await apiClient.someMethod(validatedQuery, typedBody);
    // Replace 'someMethod' with the actual generated method name

    // 4. Process and return the result
    // const processedData = processResult(result.data);

    // Return success response
    return NextResponse.json(
      {
        message: '{{this}} {{../routePath}} - Implementation needed',
        // data: processedData,
        timestamp: new Date().toISOString()
      },
      { status: 200 }
    );

  } catch (error) {
    console.error(`${new Date().toISOString()} - Error in {{this}} {{../routePath}}:`, error);

    // Handle validation errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          message: 'Validation failed',
          errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`),
          timestamp: new Date().toISOString()
        },
        { status: 400 }
      );
    }

    // Handle other known errors
    if (error.message?.includes('not found')) {
      return NextResponse.json(
        { success: false, message: 'Resource not found', timestamp: new Date().toISOString() },
        { status: 404 }
      );
    }

    if (error.message?.includes('permission') || error.message?.includes('authorization')) {
      return NextResponse.json(
        { success: false, message: 'Not authorized for this operation', timestamp: new Date().toISOString() },
        { status: 403 }
      );
    }

    // Generic server error
    return NextResponse.json(
      {
        success: false,
        message: 'Internal server error',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

{{/each}}